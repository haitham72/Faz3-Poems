<!DOCTYPE html>
<html lang="ar" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ÿ®ÿ≠ÿ´ ÿ∞ŸÉŸä - Hybrid Search V3</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
      }
      .search-box {
        background: white;
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        margin-bottom: 30px;
      }
      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 20px;
        font-size: 2em;
      }
      .search-input-group {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
      }
      input[type="text"] {
        flex: 1;
        padding: 15px;
        font-size: 18px;
        border: 2px solid #ddd;
        border-radius: 8px;
        outline: none;
        transition: border-color 0.3s;
      }
      input[type="text"]:focus {
        border-color: #667eea;
      }
      button {
        padding: 15px 30px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s;
      }
      button:hover {
        transform: translateY(-2px);
      }
      .test-buttons {
        display: flex;
        gap: 10px;
        margin-top: 15px;
        flex-wrap: wrap;
      }
      .test-btn {
        padding: 10px 20px;
        background: #f093fb;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
      }
      .test-btn:hover {
        background: #f5576c;
      }

      /* Summary Stats */
      .summary-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 12px;
        margin-bottom: 20px;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
      }
      .stat-item {
        text-align: center;
        padding: 10px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
      }
      .stat-value {
        font-size: 28px;
        font-weight: bold;
        margin-bottom: 5px;
      }
      .stat-label {
        font-size: 14px;
        opacity: 0.9;
      }

      /* Tag Pills */
      .tags-container {
        background: white;
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 20px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .tag-pill {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
        padding: 6px 15px;
        border-radius: 20px;
        font-size: 13px;
        font-weight: 600;
      }

      /* Result Cards */
      .result-card {
        background: white;
        padding: 25px;
        border-radius: 12px;
        margin-bottom: 20px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s;
        border-right: 5px solid #667eea;
      }
      .result-card:hover {
        transform: translateX(-5px);
      }
      .result-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }
      .result-title {
        font-size: 22px;
        font-weight: bold;
        color: #667eea;
        flex: 1;
      }
      .result-score {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 8px 15px;
        border-radius: 20px;
        font-weight: bold;
        font-size: 16px;
      }
      .result-poem {
        font-size: 18px;
        color: #333;
        line-height: 2;
        margin-bottom: 15px;
        white-space: pre-wrap;
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
      }
      .result-meta {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        font-size: 13px;
        color: #666;
        padding-top: 15px;
        border-top: 1px solid #eee;
      }
      .meta-item {
        background: #f5f5f5;
        padding: 5px 12px;
        border-radius: 15px;
      }
      .meta-tag {
        background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
        color: #333;
        font-weight: 600;
      }
      .meta-location {
        background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
        color: #333;
        font-weight: 600;
      }
      mark {
        background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: bold;
      }
      mark.metadata-highlight {
        background: linear-gradient(135deg, #ffe5b4 0%, #ff9966 100%);
        color: #333;
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: normal;
        border: 1px dashed #ff6600;
      }
      .loading,
      .no-results {
        text-align: center;
        padding: 40px;
        color: white;
        font-size: 18px;
        display: none;
      }
      .show {
        display: block;
      }
      .skeleton {
        background: linear-gradient(
          90deg,
          #f0f0f0 25%,
          #e0e0e0 50%,
          #f0f0f0 75%
        );
        background-size: 200% 100%;
        animation: loading 1.5s infinite;
        border-radius: 8px;
        margin-bottom: 15px;
      }
      .skeleton-title {
        height: 30px;
        width: 60%;
        margin-bottom: 15px;
      }
      .skeleton-poem {
        height: 80px;
        width: 100%;
        margin-bottom: 15px;
      }
      .skeleton-meta {
        height: 25px;
        width: 40%;
      }
      @keyframes loading {
        0% {
          background-position: 200% 0;
        }
        100% {
          background-position: -200% 0;
        }
      }
      .performance-badge {
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px 20px;
        border-radius: 8px;
        font-weight: bold;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      .fast {
        color: #10b981;
      }
      .slow {
        color: #ef4444;
      }
    </style>
  </head>
  <body>
    <div class="performance-badge" id="perfBadge" style="display: none"></div>

    <div class="container">
      <div class="search-box">
        <h1>üîç ÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑÿ∞ŸÉŸä - V3 FTS</h1>
        <div class="search-input-group">
          <input
            type="text"
            id="searchQuery"
            placeholder="ÿßÿ®ÿ≠ÿ´ ÿπŸÜ ÿ¥ÿÆÿµÿå ŸÖŸÉÿßŸÜÿå ÿ≠ÿØÿ´..."
          />
          <button onclick="searchPoems()">ÿ®ÿ≠ÿ´</button>
        </div>

        <div class="test-buttons">
          <button class="test-btn" onclick="testGrouped()">
            ÿßÿÆÿ™ÿ®ÿßÿ±: ÿßÿ≥ÿ™ÿπŸÑÿßŸÖ ŸÖÿ¨ŸÖÿπ
          </button>
          <button class="test-btn" onclick="testOldFormat()">
            ÿßÿÆÿ™ÿ®ÿßÿ±: ÿµŸäÿ∫ÿ© ŸÇÿØŸäŸÖÿ©
          </button>
          <button class="test-btn" onclick="testComplex()">ÿßÿÆÿ™ÿ®ÿßÿ±: ŸÖÿπŸÇÿØ</button>
        </div>
      </div>

      <div class="loading" id="loading">‚è≥ ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑÿ∞ŸÉŸä...</div>
      <div id="summaryContainer" style="display: none"></div>
      <div id="tagsContainer" style="display: none"></div>
      <div class="results" id="results"></div>
    </div>

    <script>
      const CONFIG = {
        // N8N Webhook URL - REPLACE WITH YOUR WEBHOOK
        N8N_WEBHOOK_URL: "https://ihisam002.app.n8n.cloud/webhook/N8N",

        // Supabase config (for direct PostgreSQL - optional fallback)
        SUPABASE_URL: "https://uffjlburuvsnstvgyito.supabase.co",
        SUPABASE_ANON_KEY:
          "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVmZmpsYnVydXZzbnN0dmd5aXRvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY1MTczMTcsImV4cCI6MjA4MjA5MzMxN30.cywWITSP-aJfuXlzyBYHf9Ipnhu-6_mVCZ30h3b1-38",

        // Set to true to use N8N, false to use direct PostgreSQL
        USE_N8N: true,
      };

      document
        .getElementById("searchQuery")
        .addEventListener("keypress", function (e) {
          if (e.key === "Enter") searchPoems();
        });

      async function searchPoems(customPayload = null) {
        const resultsDiv = document.getElementById("results");
        const loadingDiv = document.getElementById("loading");
        const summaryDiv = document.getElementById("summaryContainer");
        const tagsDiv = document.getElementById("tagsContainer");
        const perfBadge = document.getElementById("perfBadge");

        loadingDiv.classList.add("show");
        resultsDiv.innerHTML = createSkeletonCards(3);

        const startTime = performance.now();

        try {
          const queryText = document.getElementById("searchQuery").value;

          // Build payload
          const payload = customPayload || {
            query: queryText, // Simple string for N8N
            user_language: "ar",
          };

          console.log("üì§ Query payload:", payload);

          let data;

          if (CONFIG.USE_N8N) {
            // ============================================
            // CALL N8N WEBHOOK
            // ============================================
            const n8nResponse = await fetch(CONFIG.N8N_WEBHOOK_URL, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify(payload),
            });

            if (!n8nResponse.ok) {
              throw new Error(
                `N8N error: ${n8nResponse.status} - ${await n8nResponse.text()}`
              );
            }

            data = await n8nResponse.json();
            console.log("üì• N8N Response:", data);
          } else {
            // ============================================
            // FALLBACK: DIRECT POSTGRESQL
            // ============================================
            const pgPayload = customPayload || {
              N8N_query: {
                Exact_query: queryText,
                tag: "user_query",
                confidence_score: 100,
                expanded_queries: [],
                individual_Limit: 10,
                total_limit: 20,
              },
            };

            const response = await fetch(
              `${CONFIG.SUPABASE_URL}/rest/v1/rpc/hybrid_search_v2_entity_aware`,
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  apikey: CONFIG.SUPABASE_ANON_KEY,
                  Authorization: `Bearer ${CONFIG.SUPABASE_ANON_KEY}`,
                },
                body: JSON.stringify({
                  n8n_payload: pgPayload,
                  total_limit: 20,
                  min_score: 50,
                }),
              }
            );

            if (!response.ok) {
              throw new Error(
                `PostgreSQL error: ${
                  response.status
                } - ${await response.text()}`
              );
            }

            data = await response.json();
            console.log("üì• PostgreSQL Response:", data);
          }

          const endTime = performance.now();
          const duration = Math.round(endTime - startTime);

          loadingDiv.classList.remove("show");

          // Show performance badge
          perfBadge.textContent = `${duration}ms`;
          perfBadge.className = `performance-badge ${
            duration < 500 ? "fast" : "slow"
          }`;
          perfBadge.style.display = "block";
          setTimeout(() => (perfBadge.style.display = "none"), 3000);

          // Handle response (N8N format or PostgreSQL format)
          const result = Array.isArray(data) ? data[0] : data;

          if (result && result.results && result.results.length > 0) {
            displaySummary(result);
            displayTags(result.tags);
            displayResults(result.results);
          } else {
            resultsDiv.innerHTML =
              '<div class="no-results show">üòî ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÜÿ™ÿßÿ¶ÿ¨</div>';
          }
        } catch (error) {
          console.error("‚ùå Error:", error);
          loadingDiv.classList.remove("show");
          resultsDiv.innerHTML = `<div class="no-results show">‚ùå ÿÆÿ∑ÿ£: ${error.message}</div>`;
        }
      }

      function testGrouped() {
        // Simple search that will hit N8N
        document.getElementById("searchQuery").value = "ÿ®Ÿà ÿÆÿßŸÑÿØ";
        searchPoems();
      }

      function testOldFormat() {
        // Simple search that will hit N8N
        document.getElementById("searchQuery").value = "ÿ®Ÿà ÿ±ÿßÿ¥ÿØ";
        searchPoems();
      }

      function testComplex() {
        // Simple search that will hit N8N
        document.getElementById("searchQuery").value = "ÿ≤ÿßŸäÿØ";
        searchPoems();
      }

      function createSkeletonCards(count) {
        let html = "";
        for (let i = 0; i < count; i++) {
          html += `
                    <div class="result-card">
                        <div class="skeleton skeleton-title"></div>
                        <div class="skeleton skeleton-poem"></div>
                        <div class="skeleton skeleton-meta"></div>
                    </div>
                `;
        }
        return html;
      }

      function displaySummary(data) {
        const summaryDiv = document.getElementById("summaryContainer");
        summaryDiv.innerHTML = `
                <div class="summary-card">
                    <div class="stat-item">
                        <div class="stat-value">${data.poems || 0}</div>
                        <div class="stat-label">ŸÇÿµŸäÿØÿ©</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${data.lines || 0}</div>
                        <div class="stat-label">ÿ®Ÿäÿ™</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${data.words || 0}</div>
                        <div class="stat-label">ŸÉŸÑŸÖÿ©</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${data.results.length}</div>
                        <div class="stat-label">ŸÜÿ™Ÿäÿ¨ÿ©</div>
                    </div>
                </div>
            `;
        summaryDiv.style.display = "block";
      }

      function displayTags(tagsString) {
        if (!tagsString) return;
        const tagsDiv = document.getElementById("tagsContainer");
        const tags = tagsString
          .split(",")
          .map((t) => t.trim())
          .filter((t) => t);
        if (tags.length === 0) return;
        tagsDiv.innerHTML = `
                <div class="tags-container">
                    ${tags
                      .map((tag) => `<span class="tag-pill">${tag}</span>`)
                      .join("")}
                </div>
            `;
        tagsDiv.style.display = "block";
      }

      function normalizeForComparison(text) {
        if (!text) return "";
        return text
          .replace(/[^\u0600-\u06FFa-zA-Z]/g, "")
          .replace(/[\u0640]/g, "")
          .replace(/[ÿ£ÿ•ÿ¢]/g, "ÿß")
          .replace(/[Ÿâ]/g, "Ÿä")
          .replace(/[ÿ©]/g, "Ÿá");
      }

      function highlightText(rawText, matchData, displayRowId) {
        let positionsToHighlight = new Set();
        let metadataWordsToHighlight = new Set(); // For metadata fuzzy matching

        // Extract positions from matchData
        if (Array.isArray(matchData)) {
          matchData.forEach((m) => {
            if (m.positions && m.positions !== "metadata") {
              // Parse positions: "5", "5-6", or "2,5,8"
              const positions = m.positions.toString();
              if (positions.includes("-")) {
                const [start, end] = positions.split("-").map(Number);
                for (let i = start; i <= end; i++) {
                  positionsToHighlight.add(i);
                }
              } else if (positions.includes(",")) {
                positions
                  .split(",")
                  .forEach((p) => positionsToHighlight.add(Number(p.trim())));
              } else {
                positionsToHighlight.add(Number(positions));
              }
            } else if (m.positions === "metadata" && m.text) {
              // For metadata matches, add text for fuzzy matching
              metadataWordsToHighlight.add(normalizeForComparison(m.text));
            }
          });
        } else if (matchData && matchData.matched_words) {
          if (matchData.row_id && matchData.row_id !== displayRowId)
            return rawText;

          matchData.matched_words.forEach((m) => {
            if (m.positions && m.positions !== "metadata") {
              const positions = m.positions.toString();
              if (positions.includes("-")) {
                const [start, end] = positions.split("-").map(Number);
                for (let i = start; i <= end; i++) {
                  positionsToHighlight.add(i);
                }
              } else if (positions.includes(",")) {
                positions
                  .split(",")
                  .forEach((p) => positionsToHighlight.add(Number(p.trim())));
              } else {
                positionsToHighlight.add(Number(positions));
              }
            } else if (m.positions === "metadata" && m.text) {
              // For metadata matches, add text for fuzzy matching
              metadataWordsToHighlight.add(normalizeForComparison(m.text));
            }
          });
        } else {
          return rawText;
        }

        if (
          positionsToHighlight.size === 0 &&
          metadataWordsToHighlight.size === 0
        )
          return rawText;

        // Split text into words
        const words = rawText.split(/(\s+)/);
        let wordIndex = 0;

        return words
          .map((token) => {
            if (!token.trim()) return token; // Preserve whitespace

            // Position-based highlighting (EXACT)
            const shouldHighlight = positionsToHighlight.has(wordIndex);
            const tokenNorm = normalizeForComparison(token);

            // Skip tokens that normalize to empty (pure punctuation)
            if (!tokenNorm) {
              return token;
            }

            wordIndex++; // Only count actual words

            if (shouldHighlight) {
              return `<mark>${token}</mark>`;
            }

            // Metadata fuzzy highlighting (FALLBACK)
            for (let metadataWord of metadataWordsToHighlight) {
              // Split metadata phrase into words
              const metadataWords = metadataWord.split(/\s+/).filter((w) => w);

              // Check if token matches any word in the metadata phrase
              if (
                metadataWords.some(
                  (mw) =>
                    tokenNorm === mw ||
                    (tokenNorm.length > 2 && tokenNorm.includes(mw)) ||
                    (mw.length > 2 && mw.includes(tokenNorm))
                )
              ) {
                return `<mark class="metadata-highlight">${token}</mark>`;
              }
            }

            return token;
          })
          .join("");
      }

      function displayResults(results) {
        const resultsDiv = document.getElementById("results");
        let html = "";

        results.forEach((result) => {
          const titleHighlighted = highlightText(
            result.title_raw,
            result.match.title,
            null
          );

          const poemHighlighted = highlightText(
            result.poem_line_raw,
            result.match.poem_line,
            result.row_id
          );

          const hasMetadata =
            result.match.poem_line?.matched_words?.some(
              (w) => w.positions === "metadata"
            ) || false;

          html += `
                    <div class="result-card">
                        <div class="result-header">
                            <div class="result-title">${titleHighlighted}</div>
                            <div class="result-score">${result.score}</div>
                        </div>
                        <div class="result-poem">${poemHighlighted}</div>
                        <div class="result-meta">
                            <span class="meta-item">ÿ≥ÿ∑ÿ±: ${result.row_id}</span>
                            <span class="meta-item meta-location">
                                ${result.match_location.join(" + ")}
                            </span>
                            ${
                              result.tag
                                ? `<span class="meta-item meta-tag">üè∑Ô∏è ${result.tag}</span>`
                                : ""
                            }
                            ${
                              hasMetadata
                                ? '<span class="meta-item" style="background: #ffe5b4;">üìä ŸÖŸÜ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸàÿµŸÅŸäÿ©</span>'
                                : ""
                            }
                        </div>
                    </div>
                `;
        });

        resultsDiv.innerHTML = html;
      }
    </script>
  </body>
</html>
